note
	description: "Test application for simple_pdf library"
	author: "Your Organization"
	date: "$Date$"
	revision: "$Revision$"

class
	SIMPLE_PDF_TEST_APP

create
	make

feature {NONE} -- Initialization

	make
			-- Run tests
		local
			l_tests: SIMPLE_PDF_TEST_SET
		do
			print ("=== Simple PDF Tests ===%N%N")

			passed := 0
			failed := 0

			create l_tests

			-- Unit tests
			run_test (agent l_tests.test_engine_detection, "test_engine_detection")
			run_test (agent l_tests.test_wkhtmltopdf_engine_creation, "test_wkhtmltopdf_engine_creation")
			run_test (agent l_tests.test_chrome_engine_creation, "test_chrome_engine_creation")
			run_test (agent l_tests.test_simple_pdf_creation, "test_simple_pdf_creation")
			run_test (agent l_tests.test_document_failed_creation, "test_document_failed_creation")
			run_test (agent l_tests.test_reader_creation, "test_reader_creation")

			-- Manual/Integration tests
			run_manual_tests

			print ("%N========================%N")
			print ("Results: " + passed.out + " passed, " + failed.out + " failed%N")

			if failed > 0 then
				print ("TESTS FAILED%N")
			else
				print ("ALL TESTS PASSED%N")
			end
		end

feature {NONE} -- Test Infrastructure

	passed: INTEGER
	failed: INTEGER

	run_test (a_test: PROCEDURE; a_name: STRING)
			-- Run a single test and update counters.
		local
			l_retried: BOOLEAN
		do
			if not l_retried then
				a_test.call (Void)
				print ("  PASS: " + a_name + "%N")
				passed := passed + 1
			end
		rescue
			print ("  FAIL: " + a_name + "%N")
			failed := failed + 1
			l_retried := True
			retry
		end

feature -- Manual Tests

	run_manual_tests
			-- Run manual tests with output
		local
			l_engines: SIMPLE_PDF_ENGINES
		do
			print ("%N--- Integration Tests ---%N")

			-- Test engine detection
			print ("Engine Availability:%N")
			create l_engines
			print (l_engines.report)
			print ("%N")

			-- Test PDF generation if engine available
			if l_engines.any_available then
				test_html_to_pdf
				test_url_to_pdf
			else
				print ("WARNING: No PDF engine available. Skipping generation tests.%N")
			end

			-- Test PDF reading
			test_pdf_reader
		end

	test_html_to_pdf
			-- Test HTML to PDF conversion
		local
			l_pdf: SIMPLE_PDF
			l_doc: SIMPLE_PDF_DOCUMENT
			l_html: STRING
			l_output: STRING
		do
			print ("Test: HTML to PDF%N")

			l_html := "[
				<!DOCTYPE html>
				<html>
				<head>
					<title>Test PDF</title>
					<style>
						body { font-family: Arial, sans-serif; margin: 40px; }
						h1 { color: #333; }
						.content { padding: 20px; background: #f5f5f5; }
					</style>
				</head>
				<body>
					<h1>Simple PDF Test</h1>
					<div class="content">
						<p>This PDF was generated by the simple_pdf library.</p>
						<p>Generated at: ]" + (create {DATE_TIME}.make_now).out + "[</p>
					</div>
				</body>
				</html>
			]"

			create l_pdf.make
			if l_pdf.is_available then
				l_output := get_temp_dir + "/simple_pdf_test_output.pdf"

				l_doc := l_pdf.from_html (l_html)
				if l_doc.is_valid then
					if l_doc.save_to_file (l_output) then
						print ("  SUCCESS: PDF saved to " + l_output + "%N")
						passed := passed + 1
					else
						print ("  FAILED: Could not save PDF%N")
						failed := failed + 1
					end
				else
					if attached l_doc.error_message as l_err then
						print ("  FAILED: " + l_err + "%N")
					else
						print ("  FAILED: Unknown error%N")
					end
					failed := failed + 1
				end
			else
				print ("  SKIPPED: Engine not available%N")
			end
		end

	test_url_to_pdf
			-- Test URL to PDF conversion
		local
			l_pdf: SIMPLE_PDF
			l_doc: SIMPLE_PDF_DOCUMENT
			l_output: STRING
		do
			print ("Test: URL to PDF%N")

			create l_pdf.make
			if l_pdf.is_available then
				l_output := get_temp_dir + "/simple_pdf_test_url.pdf"
				l_pdf.set_page_size ("A4")

				l_doc := l_pdf.from_url ("https://example.com")
				if l_doc.is_valid then
					if l_doc.save_to_file (l_output) then
						print ("  SUCCESS: PDF saved to " + l_output + "%N")
						passed := passed + 1
					else
						print ("  FAILED: Could not save PDF%N")
						failed := failed + 1
					end
				else
					if attached l_doc.error_message as l_err then
						print ("  FAILED: " + l_err + "%N")
					else
						print ("  FAILED: Unknown error%N")
					end
					failed := failed + 1
				end
			else
				print ("  SKIPPED: Engine not available%N")
			end
		end

	test_pdf_reader
			-- Test PDF text extraction
		local
			l_reader: SIMPLE_PDF_READER
			l_text: STRING
			l_test_pdf: STRING
		do
			print ("Test: PDF Text Extraction%N")

			create l_reader.make
			if l_reader.is_available then
				l_test_pdf := get_temp_dir + "/simple_pdf_test_output.pdf"
				if (create {RAW_FILE}.make_with_name (l_test_pdf)).exists then
					l_text := l_reader.extract_text (l_test_pdf)
					if not l_text.is_empty then
						print ("  SUCCESS: Extracted " + l_text.count.out + " characters%N")
						print ("  Preview: " + l_text.substring (1, l_text.count.min (100)) + "...%N")
						passed := passed + 1
					else
						print ("  FAILED: No text extracted%N")
						if attached l_reader.last_error as l_err then
							print ("  Error: " + l_err + "%N")
						end
						failed := failed + 1
					end
				else
					print ("  SKIPPED: No test PDF available (run HTML test first)%N")
				end
			else
				print ("  SKIPPED: pdftotext not available%N")
			end
		end

feature {NONE} -- Helpers

	get_temp_dir: STRING
			-- Get system temp directory
		local
			l_env: EXECUTION_ENVIRONMENT
		do
			create l_env
			if attached l_env.item ("TEMP") as l_temp then
				Result := l_temp.to_string_8
			elseif attached l_env.item ("TMP") as l_tmp then
				Result := l_tmp.to_string_8
			else
				Result := "."
			end
		end

end
